////////////////////////////////
// Generated by CodeFormatter v1.0
// 2022-08-05, 18:48:39
////////////////////////////////
#if ODIN_INSPECTOR
using Sirenix.OdinInspector;
#endif

using System.Collections.Generic;
using UnityEngine;
namespace PureMVCFramework.Entity
{
	public abstract class SystemBase<T1> : SystemBase where T1 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
		private static long hash1 = Entity.StringToHash(typeof(T1).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			IComponentData[] c = new IComponentData[1];
			bool tf = entity.components.TryGetValue(hash1, out c[0]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add((T1)c[0]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1);
	}
	public abstract class SystemBase<T1, T2> : SystemBase where T1 : IComponentData where T2 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
		private static long hash1 = Entity.StringToHash(typeof(T1).FullName);
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			IComponentData[] c = new IComponentData[2];
			bool tf = entity.components.TryGetValue(hash1, out c[0]) && entity.components.TryGetValue(hash2, out c[1]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add((T1)c[0]);
				Components2.Add((T2)c[1]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2);
	}
	public abstract class SystemBase<T1, T2, T3> : SystemBase where T1 : IComponentData where T2 : IComponentData where T3 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T3> Components3 = new List<T3>();
		private static long hash1 = Entity.StringToHash(typeof(T1).FullName);
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		private static long hash3 = Entity.StringToHash(typeof(T3).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
			Components3.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			IComponentData[] c = new IComponentData[3];
			bool tf = entity.components.TryGetValue(hash1, out c[0]) && entity.components.TryGetValue(hash2, out c[1]) && entity.components.TryGetValue(hash3, out c[2]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add((T1)c[0]);
				Components2.Add((T2)c[1]);
				Components3.Add((T3)c[2]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i], Components3[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2, T3 component3);
	}
	public abstract class SystemBase<T1, T2, T3, T4> : SystemBase where T1 : IComponentData where T2 : IComponentData where T3 : IComponentData where T4 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T3> Components3 = new List<T3>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T4> Components4 = new List<T4>();
		private static long hash1 = Entity.StringToHash(typeof(T1).FullName);
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		private static long hash3 = Entity.StringToHash(typeof(T3).FullName);
		private static long hash4 = Entity.StringToHash(typeof(T4).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
			Components3.Clear();
			Components4.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			IComponentData[] c = new IComponentData[4];
			bool tf = entity.components.TryGetValue(hash1, out c[0]) && entity.components.TryGetValue(hash2, out c[1]) && entity.components.TryGetValue(hash3, out c[2]) && entity.components.TryGetValue(hash4, out c[3]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
					Components4.RemoveAt(i);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add((T1)c[0]);
				Components2.Add((T2)c[1]);
				Components3.Add((T3)c[2]);
				Components4.Add((T4)c[3]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i], Components3[i], Components4[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2, T3 component3, T4 component4);
	}
	public abstract class SystemBase<T1, T2, T3, T4, T5> : SystemBase where T1 : IComponentData where T2 : IComponentData where T3 : IComponentData where T4 : IComponentData where T5 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T3> Components3 = new List<T3>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T4> Components4 = new List<T4>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T5> Components5 = new List<T5>();
		private static long hash1 = Entity.StringToHash(typeof(T1).FullName);
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		private static long hash3 = Entity.StringToHash(typeof(T3).FullName);
		private static long hash4 = Entity.StringToHash(typeof(T4).FullName);
		private static long hash5 = Entity.StringToHash(typeof(T5).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
			Components3.Clear();
			Components4.Clear();
			Components5.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			IComponentData[] c = new IComponentData[5];
			bool tf = entity.components.TryGetValue(hash1, out c[0]) && entity.components.TryGetValue(hash2, out c[1]) && entity.components.TryGetValue(hash3, out c[2]) && entity.components.TryGetValue(hash4, out c[3]) && entity.components.TryGetValue(hash5, out c[4]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
					Components4.RemoveAt(i);
					Components5.RemoveAt(i);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add((T1)c[0]);
				Components2.Add((T2)c[1]);
				Components3.Add((T3)c[2]);
				Components4.Add((T4)c[3]);
				Components5.Add((T5)c[4]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i], Components3[i], Components4[i], Components5[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2, T3 component3, T4 component4, T5 component5);
	}
	public abstract class SystemBase<T1, T2, T3, T4, T5, T6> : SystemBase where T1 : IComponentData where T2 : IComponentData where T3 : IComponentData where T4 : IComponentData where T5 : IComponentData where T6 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T3> Components3 = new List<T3>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T4> Components4 = new List<T4>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T5> Components5 = new List<T5>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T6> Components6 = new List<T6>();
		private static long hash1 = Entity.StringToHash(typeof(T1).FullName);
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		private static long hash3 = Entity.StringToHash(typeof(T3).FullName);
		private static long hash4 = Entity.StringToHash(typeof(T4).FullName);
		private static long hash5 = Entity.StringToHash(typeof(T5).FullName);
		private static long hash6 = Entity.StringToHash(typeof(T6).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
			Components3.Clear();
			Components4.Clear();
			Components5.Clear();
			Components6.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			IComponentData[] c = new IComponentData[6];
			bool tf = entity.components.TryGetValue(hash1, out c[0]) && entity.components.TryGetValue(hash2, out c[1]) && entity.components.TryGetValue(hash3, out c[2]) && entity.components.TryGetValue(hash4, out c[3]) && entity.components.TryGetValue(hash5, out c[4]) && entity.components.TryGetValue(hash6, out c[5]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
					Components4.RemoveAt(i);
					Components5.RemoveAt(i);
					Components6.RemoveAt(i);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add((T1)c[0]);
				Components2.Add((T2)c[1]);
				Components3.Add((T3)c[2]);
				Components4.Add((T4)c[3]);
				Components5.Add((T5)c[4]);
				Components6.Add((T6)c[5]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i], Components3[i], Components4[i], Components5[i], Components6[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2, T3 component3, T4 component4, T5 component5, T6 component6);
	}
	public abstract class HybridSystemBase<T1, T2> : SystemBase where T1 : Component where T2 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			if (entity.gameObject == null)
			{
				if (Entities.Contains(entity))
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
				}
				return;
			}
			var co = entity.gameObject.GetComponent<T1>();
			IComponentData[] c = new IComponentData[1];
			bool tf = co && entity.components.TryGetValue(hash2, out c[0]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					OnEject(entity, co);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add(co);
				Components2.Add((T2)c[0]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2);
		protected virtual void OnEject(Entity entity, T1 component) { }
	}
	public abstract class HybridSystemBase<T1, T2, T3> : SystemBase where T1 : Component where T2 : IComponentData where T3 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T3> Components3 = new List<T3>();
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		private static long hash3 = Entity.StringToHash(typeof(T3).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
			Components3.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			if (entity.gameObject == null)
			{
				if (Entities.Contains(entity))
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
				}
				return;
			}
			var co = entity.gameObject.GetComponent<T1>();
			IComponentData[] c = new IComponentData[2];
			bool tf = co && entity.components.TryGetValue(hash2, out c[0]) && entity.components.TryGetValue(hash3, out c[1]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
					OnEject(entity, co);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add(co);
				Components2.Add((T2)c[0]);
				Components3.Add((T3)c[1]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i], Components3[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2, T3 component3);
		protected virtual void OnEject(Entity entity, T1 component) { }
	}
	public abstract class HybridSystemBase<T1, T2, T3, T4> : SystemBase where T1 : Component where T2 : IComponentData where T3 : IComponentData where T4 : IComponentData 
	{
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T1> Components1 = new List<T1>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T2> Components2 = new List<T2>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T3> Components3 = new List<T3>();
#if ODIN_INSPECTOR
		[ShowIf("showOdinInfo"), ShowInInspector, ListDrawerSettings(IsReadOnly = true)]
#endif
		private readonly List<T4> Components4 = new List<T4>();
		private static long hash2 = Entity.StringToHash(typeof(T2).FullName);
		private static long hash3 = Entity.StringToHash(typeof(T3).FullName);
		private static long hash4 = Entity.StringToHash(typeof(T4).FullName);
		internal sealed override void OnStopRunningInternal()
		{
			base.OnStopRunningInternal();
			Components1.Clear();
			Components2.Clear();
			Components3.Clear();
			Components4.Clear();
		}
		public sealed override void InjectEntity(Entity entity)
		{
			if (entity.gameObject == null)
			{
				if (Entities.Contains(entity))
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
					Components4.RemoveAt(i);
				}
				return;
			}
			var co = entity.gameObject.GetComponent<T1>();
			IComponentData[] c = new IComponentData[3];
			bool tf = co && entity.components.TryGetValue(hash2, out c[0]) && entity.components.TryGetValue(hash3, out c[1]) && entity.components.TryGetValue(hash4, out c[2]);
			if (Entities.Contains(entity))
			{
				if (!tf)
				{
					var i = Entities.IndexOf(entity);
					Entities.RemoveAt(i);
					Components1.RemoveAt(i);
					Components2.RemoveAt(i);
					Components3.RemoveAt(i);
					Components4.RemoveAt(i);
					OnEject(entity, co);
				}
			}
			else if (tf)
			{
				Entities.Add(entity);
				Components1.Add(co);
				Components2.Add((T2)c[0]);
				Components3.Add((T3)c[1]);
				Components4.Add((T4)c[2]);
			}
		}
		protected sealed override void OnUpdate()
		{
			for (int i = 0; i < Entities.Count; ++i)
			{
				OnUpdate(i, Entities[i], Components1[i], Components2[i], Components3[i], Components4[i]);
			}
		}
		protected abstract void OnUpdate(int index, Entity entity, T1 component1, T2 component2, T3 component3, T4 component4);
		protected virtual void OnEject(Entity entity, T1 component) { }
	}
}
